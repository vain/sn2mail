#!/bin/bash

rcfile=${SN2MAILRC:-~/.sn2mailrc}
[[ ! -r "$rcfile" ]] && { echo "No settings found.">&2; exit 1; }
. "$rcfile"

lock="/tmp/sn2mail-get-lock"
if ! mkdir "$lock" &>/dev/null
then
	echo "sn2mail-get already running. Aborting." >&2
	exit 1
fi
trap 'rm -Rf "$lock"' EXIT

# Don't fetch all entries if this is not our first run.
[[ -f $idcache ]] && last_id="&since_id=$(< "$idcache")"

# Common prefix for message IDs. Hash user, pass and url so it's
# possible to fetch from different accounts.
mid_pre="microblog-$(echo "$user$pass$url" | md5sum | cut -d ' ' -f1)-"

# Try to find XSLT sheet.
sheet=
for d in "$(dirname "$(readlink -f "$0")")" /usr/share/sn2mail
do
	[[ -r $d/timeline.xslt ]] && { sheet="$d/timeline.xslt"; break; }
done
[[ -z $sheet ]] && { echo "Can't find XSLT sheet." >&2; exit 1; }

# Use xmlstarlet to parse the XML.
first=yes
page=$(curl -f --user "$user:$pass" -s \
	"$url/statuses/public_timeline.xml?count=200$last_id")
ret=$?
if (( ret != 0 ))
then
	echo "curl failed: exit code was $ret" >&2
	exit 1
fi

echo "$page" | xmlstarlet tr "$sheet" |
while read -r notice_id
do
	read -r notice_in_reply_to
	read -r notice_user
	read -r notice_created_at
	read -r notice_text

	# Format and crop text.
	notice_text_fmt=$(echo "$notice_text" | fmt)
	notice_text_crop=${notice_text:0:60}
	(( ${#notice_text} > 60 )) && notice_text_crop="$notice_text_crop..."

	# Save the most recent ID for the next run.
	[[ $first == yes ]] && { echo "$notice_id" >"$idcache"; first=no; }

	# Does this notice have references?
	ref=
	[[ -n $notice_in_reply_to ]] && ref="<$mid_pre$notice_in_reply_to>"

	# Send an e-mail. Use sendmail directly so we have full control.
	${SENDMAIL:-sendmail} "$to" <<EOF
From: "${notice_user//\"/}" <$from>
Subject: $notice_text_crop
Message-ID: <$mid_pre$notice_id>
In-Reply-To: $ref
Date: $(date -R -d "$notice_created_at")

$notice_text_fmt
EOF
done
